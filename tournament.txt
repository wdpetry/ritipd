--------------------------------------------------------------------------------
Section 0 - Line up
--------------------------------------------------------------------------------
Player 0 (P0): DizzyLizzy, RanDOMnESs
        How does this strategy decide?
Player 1 (P1): unknown, I like colluders
        Based on you
Player 2 (P2): kar, pairs
        looks for last time there was a pair like the last two
Player 3 (P3): Radaszkiewicz, MontoCarlo
        This method will c for the first 10 moves.  Then it will respond the bes
        t to what I did last time?
--------------------------------------------------------------------------------
Section 1 - Player vs. Player
--------------------------------------------------------------------------------
Each column shows pts/round earned against each other player:
             P0     P1     P2     P3
vs. P0 :      0   -180   -136   -190
vs. P1 :   -140      0      0      0
vs. P2 :   -194      0      0      0
vs. P3 :   -144      0      0      0
TOTAL  :   -478   -180   -136   -190
--------------------------------------------------------------------------------
Section 2 - Leaderboard
--------------------------------------------------------------------------------
Average points per round:
Team name (P#):  Score      with strategy name
kar       (P2):        -34 points with pairs                                   
unknown   (P1):        -45 points with I like colluders                        
Radaszkiew(P3):        -48 points with MontoCarlo                              
DizzyLizzy(P0):       -120 points with RanDOMnESs                              
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
team0--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####
import random

team_name = 'DizzyLizzy'#The name the team gives to itself' # Only 10 chars displayed.
strategy_name = 'RanDOMnESs' #the name the team gives to this strategy'
strategy_description = 'How does this strategy decide?'

def move(my_history, their_history, my_score, their_score):
    ''' Arguments accepted: my_history, their_history are strings.
    my_score, their_score are ints.

    Make my move.
    Returns 'c' or 'b'.
    '''

    # my_history: a string with one letter (c or b) per round that has been played with this opponent.
    # their_history: a string of the same length as history, possibly empty.
    # The first round between these two players is my_history[0] and their_history[0].
    # The most recent round is my_history[-1] and their_history[-1].

    # Analyze my_history and their_history and/or my_score and their_score.
    # Decide whether to return 'c' or 'b'.

    return  random.choice (['b','c'])


def test_move(my_history, their_history, my_score, their_score, result):
    '''calls move(my_history, their_history, my_score, their_score)
    from this module. Prints error if return value != result.
    Returns True or False, dpending on whether result was as expected.
    '''
    real_result = move(my_history, their_history, my_score, their_score)
    if real_result == result:
        return True
    else:
        print("move(" +
            ", ".join(["'"+my_history+"'", "'"+their_history+"'",
                       str(my_score), str(their_score)])+
            ") returned " + "'" + real_result + "'" +
            " and should have returned '" + result + "'")
        return False

if __name__ == '__main__':

    # Test 1: Betray on first move.
    if test_move(my_history='',
              their_history='',
              my_score=0,
              their_score=0,
              result='b'):
         print 'Test passed'
     # Test 2: Continue betraying if they collude despite being betrayed.
    test_move(my_history='bbb',
              their_history='ccc',
              # Note the scores are for testing move().
              # The history and scores don't need to match unless
              # that is relevant to the test of move(). Here,
              # the simulation (if working correctly) would have awarded
              # 300 to me and -750 to them. This test will pass if and only if
              # move('bbb', 'ccc', 0, 0) returns 'b'.
              my_score=0,
              their_score=0,
              result='b')
--------------------------------------------------------------------------------
team1--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'unknown' # Only 10 chars displayed.
strategy_name = 'I like colluders'
strategy_description = 'Based on you'
    
#def move(my_history, their_history, my_score, their_score):
#    ''' Arguments accepted: my_history, their_history are strings.
#    my_score, their_score are ints.
#    
#    Make my move.
#    Returns 'c' or 'b'. 
#    '''
#
#    # my_history: a string with one letter (c or b) per round that has been played with this opponent.
#    # their_history: a string of the same length as history, possibly empty. 
#    # The first round between these two players is my_history[0] and their_history[0].
#    # The most recent round is my_history[-1] and their_history[-1].
#    
#    # Analyze my_history and their_history and/or my_score and their_score.
#    # Decide whether to return 'c' or 'b'.
#    
#    return 'c'


def move(my_history, their_history, my_score, their_score):
    redeem=0#create a redeem value 
    if len(my_history)==0: # It's the first round; collude.
        return 'c'
    else:
        for i in range(0,len(my_history)-1): 
            if (my_history[-1 * i] == 'c'):     
                redeem +=1   #based on the number of times they've colluded with me.
            
    
        
        if my_history[-1]=='c' and their_history[-1]=='b':
            return 'b' # Betray if severely punished last time
        if len(my_history)>=3:    
            if their_history[-2]=='c' or their_history[-3]=='c':
                return 'c' # collude if they've colluded recently
        
            elif ( (redeem / len(my_history) )*100>10 ): 
                return 'c'# collude if they've colluded more than 10% of the time

        if my_history[-1]=='c' and their_history[-1]=='c':
            return 'c' # if we both colluded last time, collude again
        else:
            return 'b' # otherwise betray



    
def test_move(my_history, their_history, my_score, their_score, result):
    '''calls move(my_history, their_history, my_score, their_score)
    from this module. Prints error if return value != result.
    Returns True or False, dpending on whether result was as expected.
    '''
    real_result = move(my_history, their_history, my_score, their_score)
    if real_result == result:
        return True
    else:
        print("move(" +
            ", ".join(["'"+my_history+"'", "'"+their_history+"'",
                       str(my_score), str(their_score)])+
            ") returned " + "'" + real_result + "'" +
            " and should have returned '" + result + "'")
        return False

if __name__ == '__main__':
     
    # Test 1: Betray on first move.
    if test_move(my_history='',
              their_history='', 
              my_score=0,
              their_score=0,
              result='b'):
         print 'Test passed'
     # Test 2: Continue betraying if they collude despite being betrayed.
    test_move(my_history='bbb',
              their_history='ccc', 
              # Note the scores are for testing move().
              # The history and scores don't need to match unless
              # that is relevant to the test of move(). Here,
              # the simulation (if working correctly) would have awarded 
              # 300 to me and -750 to them. This test will pass if and only if
              # move('bbb', 'ccc', 0, 0) returns 'b'.
              my_score=0, 
              their_score=0,
              result='b')             --------------------------------------------------------------------------------
team2--------------------------------------------------------------------------------
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'kar' # Only 10 chars displayed.
strategy_name = 'pairs'
strategy_description = 'looks for last time there was a pair like the last two'
    
def move(my_history, their_history, my_score, their_score):
    ''' Arguments accepted: my_history, their_history are strings.
    my_score, their_score are ints.
    
    Make my move.
    Returns 'c' or 'b'. 
    '''

    # my_history: a string with one letter (c or b) per round that has been played with this opponent.
    # their_history: a string of the same length as history, possibly empty. 
    # The first round between these two players is my_history[0] and their_history[0].
    # The most recent round is my_history[-1] and their_history[-1].
    
    # Analyze my_history and their_history and/or my_score and their_score.
    # Decide whether to return 'c' or 'b'.
    if (len(my_history)<=2): # Collude on first two rounds
        return 'c'
    elif (their_history[-1]=='b'):
        return 'b'
    else:
        
        for play in range(len(their_history)-3,1,-1):
            sub_me=my_history[play:play+1]
            sub_them=their_history[play:play+1]
            
            if (sub_them==sub_me):
                return their_history[play+2]
        
        # No match found
        if my_history[-1]=='c' and their_history[-1]=='b':
            return 'b' # Betray if they were severely punished last time
        else:
            return 'c' # Otherwise collude.
    
def test_move(my_history, their_history, my_score, their_score, result):
    '''calls move(my_history, their_history, my_score, their_score)
    from this module. Prints error if return value != result.
    Returns True or False, dpending on whether result was as expected.
    '''
    real_result = move(my_history, their_history, my_score, their_score)
    if real_result == result:
        return True
    else:
        print("move(" +
            ", ".join(["'"+my_history+"'", "'"+their_history+"'",
                       str(my_score), str(their_score)])+
            ") returned " + "'" + real_result + "'" +
            " and should have returned '" + result + "'")
        return False

if __name__ == '__main__':
     
    # Test 1: Betray on first move.
    if test_move(my_history='',
              their_history='', 
              my_score=0,
              their_score=0,
              result='b'):
         print 'Test passed'
     # Test 2: Continue betraying if they collude despite being betrayed.
    test_move(my_history='bbb',
              their_history='ccc', 
              # Note the scores are for testing move().
              # The history and scores don't need to match unless
              # that is relevant to the test of move(). Here,
              # the simulation (if working correctly) would have awarded 
              # 300 to me and -750 to them. This test will pass if and only if
              # move('bbb', 'ccc', 0, 0) returns 'b'.
              my_score=0, 
              their_score=0,
              result='b')             --------------------------------------------------------------------------------
team3--------------------------------------------------------------------------------
from random import *
####
# Each team's file must define four tokens:
#     team_name: a string
#     strategy_name: a string
#     strategy_description: a string
#     move: A function that returns 'c' or 'b'
####

team_name = 'Radaszkiewicz' # Only 10 chars displayed.
strategy_name = 'MontoCarlo'
strategy_description = 'This method will c for the first 10 moves.  Then it will respond the best to what I did last time?'
    
def move(my_history, their_history, my_score, their_score):
    ''' Arguments accepted: my_history, their_history are strings.
    my_score, their_score are ints.
    
    Make my move.
    Returns 'c' or 'b'. 
    '''

    # my_history: a string with one letter (c or b) per round that has been played with this opponent.
    # their_history: a string of the same length as history, possibly empty. 
    # The first round between these two players is my_history[0] and their_history[0].
    # The most recent round is my_history[-1] and their_history[-1].
    
    # Analyze my_history and their_history and/or my_score and their_score.
    # Decide whether to return 'c' or 'b'.
    
    if len(my_history)<10:
        return 'c'
    else:
        my_LastMove = my_history[-1]
        bCount=0
        cCount=0
        for i in range(len(my_history)):
            if my_history[i-1]==my_LastMove:
                if their_history[i]=='b':
                    bCount+=1
                else:
                    cCount+=1
        x = randint(1,bCount+cCount)
        if x<bCount:
            return 'b'
        else:
            return 'c'
        

    
def test_move(my_history, their_history, my_score, their_score, result):
    '''calls move(my_history, their_history, my_score, their_score)
    from this module. Prints error if return value != result.
    Returns True or False, dpending on whether result was as expected.
    '''
    real_result = move(my_history, their_history, my_score, their_score)
    if real_result == result:
        return True
    else:
        print("move(" +
            ", ".join(["'"+my_history+"'", "'"+their_history+"'",
                       str(my_score), str(their_score)])+
            ") returned " + "'" + real_result + "'" +
            " and should have returned '" + result + "'")
        return False

if __name__ == '__main__':
     
    # Test 1: Betray on first move.
    if test_move(my_history='',
              their_history='', 
              my_score=0,
              their_score=0,
              result='b'):
         print 'Test passed'
     # Test 2: Continue betraying if they collude despite being betrayed.
    test_move(my_history='bbb',
              their_history='ccc', 
              # Note the scores are for testing move().
              # The history and scores don't need to match unless
              # that is relevant to the test of move(). Here,
              # the simulation (if working correctly) would have awarded 
              # 300 to me and -750 to them. This test will pass if and only if
              # move('bbb', 'ccc', 0, 0) returns 'b'.
              my_score=0, 
              their_score=0,
              result='b')             --------------------------------------------------------------------------------
Section 3 - Game Data for Team DizzyLizzy
--------------------------------------------------------------------------------
-140 pt/round: DizzyLizzy(P0) "RanDOMnESs"
-180 pt/round: unknown(P1) "I like colluders"
BcbCBbBcbBbbbbbccCBcCBbCCBcBcBcBcBbCCCCBcCCCBbBbccCCCCBcCCBbBbcbCBcBbBccBcBbCCBb
cBbCcbcBbcbbbbbBBCcBCcbCCcBcBcBcBcbCCCCcBCCCcbcbBBCCCCcBCCcbcbBbCcBcbcBBcBcbCCcb

BcbCBbCCBcBbBcbBbccBbCCC
cBbCcbCCcBcbcBbcbBBcbCCC

--------------------------------------------------------------------------------
-194 pt/round: DizzyLizzy(P0) "RanDOMnESs"
-136 pt/round: kar(P2) "pairs"
CBBcCCBcCCCCCCBcBcBbbbbbcCCCCCBbccCBcBbcBbbcBcbbcBccccccbccCCBbccCCCBcBcBbbcCBbb
CccBCCcBCCCCCCcBcBcbbbbbBCCCCCcbBBCcBcbBcbbBcBbbBcBBBBBBbBBCCcbBBCCCcBcBcbbBCcbb

bbcCCCCCBbccBbcCCBbcbccBcBcCCBbbbcBcbccBbbcCCBcBcBbbbcB
bbBCCCCCcbBBcbBCCcbBbBBcBcBCCcbbbBcBbBBcbbBCCcBcBcbbbBc

--------------------------------------------------------------------------------
-144 pt/round: DizzyLizzy(P0) "RanDOMnESs"
-190 pt/round: Radaszkiewicz(P3) "MontoCarlo"
CBCBCBBCCCbCbBCcBbCCCcbBcBbbCbCBBbbCbBCbccbbBcbBcBccbccbcbcbbbbCBcbCBBBBbbBbbcCb
CcCcCccCCCbCbcCBcbCCCBbcBcbbCbCccbbCbcCbBBbbcBbcBcBBbBBbBbBbbbbCcBbCccccbbcbbBCb

CBCbbCBbBCBccBCbCBBccCccBbBCbCBbcCBBc
CcCbbCcbcCcBBcCbCccBBCBBcbcCbCcbBCccB

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Section 3 - Game Data for Team unknown
--------------------------------------------------------------------------------
-180 pt/round: unknown(P1) "I like colluders"
-140 pt/round: DizzyLizzy(P0) "RanDOMnESs"
cBbCcbcBbcbbbbbBBCcBCcbCCcBcBcBcBcbCCCCcBCCCcbcbBBCCCCcBCCcbcbBbCcBcbcBBcBcbCCcb
BcbCBbBcbBbbbbbccCBcCBbCCBcBcBcBcBbCCCCBcCCCBbBbccCCCCBcCCBbBbcbCBcBbBccBcBbCCBb

cBbCcbCCcBcbcBbcbBBcbCCC
BcbCBbCCBcBbBcbBbccBbCCC

--------------------------------------------------------------------------------
0 pt/round: unknown(P1) "I like colluders"
0 pt/round: kar(P2) "pairs"
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

CCCCCCC
CCCCCCC

--------------------------------------------------------------------------------
0 pt/round: unknown(P1) "I like colluders"
0 pt/round: Radaszkiewicz(P3) "MontoCarlo"
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Section 3 - Game Data for Team kar
--------------------------------------------------------------------------------
-136 pt/round: kar(P2) "pairs"
-194 pt/round: DizzyLizzy(P0) "RanDOMnESs"
CccBCCcBCCCCCCcBcBcbbbbbBCCCCCcbBBCcBcbBcbbBcBbbBcBBBBBBbBBCCcbBBCCCcBcBcbbBCcbb
CBBcCCBcCCCCCCBcBcBbbbbbcCCCCCBbccCBcBbcBbbcBcbbcBccccccbccCCBbccCCCBcBcBbbcCBbb

bbBCCCCCcbBBcbBCCcbBbBBcBcBCCcbbbBcBbBBcbbBCCcBcBcbbbBc
bbcCCCCCBbccBbcCCBbcbccBcBcCCBbbbcBcbccBbbcCCBcBcBbbbcB

--------------------------------------------------------------------------------
0 pt/round: kar(P2) "pairs"
0 pt/round: unknown(P1) "I like colluders"
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

CCCCCCC
CCCCCCC

--------------------------------------------------------------------------------
0 pt/round: kar(P2) "pairs"
0 pt/round: Radaszkiewicz(P3) "MontoCarlo"
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

CCC
CCC

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Section 3 - Game Data for Team Radaszkiewicz
--------------------------------------------------------------------------------
-190 pt/round: Radaszkiewicz(P3) "MontoCarlo"
-144 pt/round: DizzyLizzy(P0) "RanDOMnESs"
CcCcCccCCCbCbcCBcbCCCBbcBcbbCbCccbbCbcCbBBbbcBbcBcBBbBBbBbBbbbbCcBbCccccbbcbbBCb
CBCBCBBCCCbCbBCcBbCCCcbBcBbbCbCBBbbCbBCbccbbBcbBcBccbccbcbcbbbbCBcbCBBBBbbBbbcCb

CcCbbCcbcCcBBcCbCccBBCBBcbcCbCcbBCccB
CBCbbCBbBCBccBCbCBBccCccBbBCbCBbcCBBc

--------------------------------------------------------------------------------
0 pt/round: Radaszkiewicz(P3) "MontoCarlo"
0 pt/round: unknown(P1) "I like colluders"
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

--------------------------------------------------------------------------------
0 pt/round: Radaszkiewicz(P3) "MontoCarlo"
0 pt/round: kar(P2) "pairs"
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

CCC
CCC

--------------------------------------------------------------------------------
